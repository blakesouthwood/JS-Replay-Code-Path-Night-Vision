<html>
<head>

  </head>

<body>
  February 12, 2019<br>
  The beginning of Replay started back in 2017 in Florida.<br>
  I made a reverse dictionary and started on the debug view.<br>
  I integrated them together in a rush.<br><br>
  To be clear the Replay Code Path is for pinpointing <b>LOGIC ERRORS</b><br>
  and to ensure that functions are called and what they do with return values.<br>
  All code is about creating running machine behavior which is designed in boolean logic.<br><br>
  Each function can be described by what it's supposed to do and how it works in English.<br>
  the design of a function is typically described procedurally in steps and then pseudocode.<br>
  The complexity of functions can quickly get out of hand due to trying too much.<br>
  <br>
  <br>Logic errors(bugs) result in designed behavior running incorrectly.<br>
  The point is to see what the code did (what path it took in the flow of control)<br>
  which functions were called and when and what the inputs and outputs of all<br>
  functions were.<br>
  Logic errors are the most vexing to detect and isolate and with this tool<br>
  it will be faster and easier to know(see) what the code logic did. <br><br>
  My motto for debugging has always been: <br>
  First look at the human logic (how a function or chunk of code is supposed to do)<br>
  second look at the pseudocode logic design structure of a function<br>
  third look at the code and see if the logic is represented correctly.<br>
  fourth look at the results of the function to determine where the logic is in erro.<br>
  fifth it's common for the actual design to be flawed because..<br>
  there isn't currently a logic checker(for soundness) when designing a function<br>
  but I will work on that next.<br><br>
  
  But I lost interest because it didn't provide the valuable info<br>
  that I needed immediately accessible such as what the code was<br>
  supposed to do at each point and what should happen and what<br>
  shouldn't happen.<br><br>
  I wanted to see trace feedback of functions called in the web<br>
  page as I used the code rather than in the console.log and without<br>
  annoying alerts and then I wanted to see var values. But I realize<br>
  now that it's important to see (where) I am in the code while it's <br>
  running so I'm going to add that with a map view with levels.<br>
<br><br>
  I built the reverse dictionary in 2017 as a prototype to <br>
see what I could do and after 2 years got the ideas <br>
to improve it so that it provided more information. <br>
<br><br>
Replay will also store the JS errors detected by the browser debugger<br>
and show them with the line number and next to the function where<br>
they were detected.<br><br>

I was testing my debugging visual tool by adding it <br>
to the reverse dictionary. <br>
<br><br>
The initial debugging aid showed thet trace growing function<br>
list but it revealed where improvements could be made with<br>
more information and the idea of understanding more about<br>
what the code's flow of control route is *after* it runs <br>
to be a true debugging tool for humans.<br>
 <br><br>
 As Brooks always said, First Throw One Away, meaning that<br>
 the first attempt is based on wrong assumptions. But at the<br>
 same time the first experience making a debugging tool revealed<br>
 most importantly that I needed more information - visually -<br>
 to see the path visually and the true course that the code took<br>
 along with assertions and the values at each point clickable<br>
 on the screen that the machine saw.<br>
<br><br>
I also learned that I need to have the literate programming view<br>
and pseudocode for each function to compare with the source code<br>
side by side so that I can see if the logic design meshes with<br>
what the code is supposed to do.<br> True comments rarely do justice<br>
to describe the inner workings (how a function or chunk works). <br>
and most importantly what's missing is what the programmer was<br>
thinking in terms of the desired behavior for a function and <br>
precisely what it does and inside the function what it does in steps.<br>
<br>
Debugging logic is vexing because the machine executes the code logic<br>
that a human wrote and it blindly obeys so making sure that the<br>
boolean logic is correct representing human logic is also important<br>
and most importantly that the human's translation from what the code<br>
is supposed to do described in English (literate programming/ Intentional)<br>
is translated in a programmer's mind into source code. Do to time constraints<br>
pseudocode is rarely the midstep taken and just source code sprinkled<br>
with a few comments is the output.<br><br>
The other part that I wanted to add was tracking reused code frequency<br>
percentage.<br> And I wanted to be able to track where "logic bugs" tend<br>
to cluster.<br>
The Replay program will be integrated as a js file in a program but the<br>
programmer will have to add some methods to their code which should<br>
not take more than a few minutes for a ten page program.<br>
For larger programs Replay will have to work on node.js due to huge log<br>
files.<br>

I will start coding the Replay program this week.
<br>

  <body>
</html>
